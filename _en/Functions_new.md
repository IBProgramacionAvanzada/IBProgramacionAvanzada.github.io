## So what is a function anyway?



Since we are about to learn functional programming, we need to agree in what a _function_ is in this context. Let us start with a set of entities, for example, the cars parked in a given block of a street. One can identify each car by its license plate, and then build a table with two columns: the first one with the license plate, and the second one with the corresponding the color of each car:

| Lic. Plate | Color         | 
| :----------: |:-------------:|
| ABC 124 | black |
| DEF 350 | red   |
| QRZ 441 | black |
| JPG 255 | white | 

That's a function that we can call `carColor`, that associates each car of the block with its color. The table is a representation of that function. A function from a set of entities A to a set of entities B is then a relation that associates elements between the sets A and B, with the property that each and every element of A has a one and only one corresponding element of B. 

There are two things to note. First, a function is defined _from_ one set _to_ another set, in our example, from the set of license plates to the set of colors. To get the color of a particular car, you go to the table representation of the function, look up the plate in the column of license plates, and get the color from the second column. With this in mind, one can identify the _from_ set as the _input_ of the function, while the _to_ set is the _output_. 

Second, all elements of the input must relate to some element in the output set. In our example, every car in the block has a color assigned in the table. This means that there cannot be empty cells in the second column of our table. 

> ‚ùì Can you come up with more examples of functions in the real world? 

In math, functions are ubiquitous. Let us assume that $x$ is a real number, and define the function

$$
f(x) = x + 1, 
$$

that is, the function that returns the value $x$ plus one. The input set (which is called the _domain_ of the function in math) is the set of all real values, $\mathbb{R}$, while the output set (the _codomain_ in math) is also $\mathbb{R}$, because adding one to any real number is also another real number. Using the _arrow_ notation, the complete definition of the function would be

$$
f: \mathbb{R} \rightarrow \mathbb{R} \; ; \;  x \mapsto x + 1,
$$

that can be read as following: $f$ is a function from $\mathbb{R}$ to $\mathbb{R}$ such that $f$ of $x$ is $x + 1$".

> üîî A slight detour around the codomain. The codomain is the set of entities where the function can possibly map input values into. For example, in the case of the color of the cars, the codomain is simply the set of all the possible colors. In many cases that information is too general, and it is convenient to define the _range_ of the function, which is the set of actual values of outputs the function maps inputs into. The range in the cars example is the set {black, red, white}.

### Multiple inputs and outputs

Let us take the example of a vending machine. In a vending machine, products are arranged in shelves, where each shelf is named by a letter. In each shelf, the products are aligned and identified by a number. Then, in A1 you have a bag of chips, in A2 a chocolate, in B1 a soda, and so on. The machine also has a keyboard with letters and numbers for you to choose the product. To buy something, you need to give the machine some money (coins, bills, credit card, etc), select the product by clicking the letter and the number on the keyboard. The machine returns the product and some cashback, if any. 
The inputs of our `vendingMachine` function are the money, the letter and the number you selected, and the outputs are the product and 
the cashback (if any). 

An example from math could be a translation function, where given a point with coordinates \(x\) and $y$ in the plane, it returns a point with coordinates $x+1$ and $y+1$:

$$
g: \mathbb{R} \times \mathbb{R} \rightarrow \mathbb{R} \times \mathbb{R}  \; ; \;  (x,y) \mapsto (x + 1, y+1)
$$

or more succintly

$$
g(x,y) = (x+1,y+1)
$$

### Partial application 
When we feed a function of several input elements, we can obtain the proper output(s). But having many inputs opens a new possibility: what happens when one decides not to complete all the inputs? Let us find out. Let us assume that we entered a bill into the vending machine. It is clear that we will not get any product, because the machine still needs two more inputs: the letter of the shelf and the product number that we want. _After_ we complete these two inputs, we will get our treat (and cashback, if any). So, entering money only in the vending machine leads to a state where two inputs are needed and two outputs will be returned. But, this is _another function_!!!. Let us call it `vendingMachineAfterInsertBill` that receives the letter of the shelf and the product number that we want and returns the product (and cashback, if any). 

Going back to the math example, let us feed the function with just the $x = 3$ value, 

$$
g(3,y) = (4,y+1)
$$

Again, the result of feeding the function with one value is another function:

$$
h: \mathbb{R} \rightarrow \mathbb{R} \times \mathbb{R}  \; ; \;  y \mapsto (4, y+1)
$$

or 

$$
h(y) = (4,y+1)
$$

This property of functions is called _partial application_. Whenever you do not complete all the inputs of a function, you get another function.

### Composition 
 
Finally, we look here how to work with several functions at once. Let us assume that we have a function `getFirstName` that given the full name of a person, it returns the first name (it does not matter at this point the specifics of the implementation, not even the language). For example, when applied to 'David Gilmour', it returns 'David', or when applied to 'Annie Lennox', it returns, of course 'Annie'.
We also have a function `getInitial` that for a given name, it returns the initial. In the previous cases, 'D' for 'David' and 'A' for 'Annie'. 

Now we want to build a function that gives us the initial of the first name, given the full name. For 'Paul McCartney'. We feed 'Paul McCartney' as input to the function `getFirstName`, which gives us the output 'Paul'. Now, 'Paul' is the input of the function `getInitial` and returns 'P' as the final output. 
This plumbing where the output of one function is the input of another is called _composition_. Note that it is absolutely necessary that the output of the first called function (`getFirstName`) and the input of the second one (`getInitial`) are the same kind of entity, in our case, both are first names.
You can [see this pictures for a graphical explanation](https://mathinsight.org/function_machine_composition).

Let us now look at a math example. We defined before the function $f(x)$ that adds one to $x$, for example 

$$
f(0) = 0 + 1 = 1
$$

What if we apply the $f$ function again? It means to compute

$$
f(f(0)) = f(0) + 1 = 0 + 1 + 1 = 2 
$$

In general,

$$
f(f(x)) = f(x) + 1 = x + 1 + 1 = x + 2 
$$

If we look carefully to the last expression, it looks like composing the function is like passing the function as the input itself ($f(f(x))$). This means that if we are going to have a programming language that implements function composition, in some way functions should be able to be passed as input to another functions. 

> ‚ùóÔ∏è The fact that we use the same function to compose with itself is not relevant to this discussion, one can compose as many different functions as one wants, provided that inputs and outputs are compatible in each composition step.

> üîî However, composing that particular function with itself is interesting. Imaging having only the zero and this function. You can create all the natural numbers {1, 2, ...} just by composing this function with itself again and again. For example, $4 = f(f(f(f(0))))$, and so on. Therefore, given the number 0, $f(x) = x + 1$ and function composition, one can get all the natural numbers. Looks like there is something going on here. More on this, hopefully, in a future episode.


## Qu'est-ce qu'une fonction ?



Puisque nous sommes sur le point d'apprendre la programmation fonctionnelle, nous devons nous mettre d'accord sur ce qu'est une _fonction_ dans ce contexte. Commen√ßons par un ensemble d'entit√©s, par exemple, les voitures gar√©es dans un bloc donn√© d'une rue. On peut identifier chaque voiture par sa plaque d'immatriculation, puis construire un tableau √† deux colonnes : la premi√®re avec la plaque d'immatriculation, et la seconde avec la couleur correspondante de chaque voiture :

non d√©fini Lic. Plaque undefined Couleur undefined
non d√©fini :----------¬†: non d√©fini¬†:----------------------¬†: non d√©fini
ind√©fini ABC 124 ind√©fini noir ind√©fini
ind√©fini DEF 350 ind√©fini rouge ind√©fini
undefined QRZ 441 undefined noir undefined
ind√©fini JPG 255 ind√©fini blanc ind√©fini

C'est une fonction que nous pouvons appeler `carColor`, qui associe chaque voiture du bloc √† sa couleur. Le tableau est une repr√©sentation de cette fonction. Une fonction d'un ensemble d'entit√©s A vers un ensemble d'entit√©s B est alors une relation qui associe des √©l√©ments entre les ensembles A et B, avec la propri√©t√© que chaque √©l√©ment de A a un et un seul √©l√©ment correspondant de B.

Il y a deux choses √† noter. Premi√®rement, une fonction est d√©finie _de_ un ensemble _√†_ un autre ensemble, dans notre exemple, de l'ensemble des plaques d'immatriculation √† l'ensemble des couleurs. Pour obtenir la couleur d'une voiture particuli√®re, vous acc√©dez √† la repr√©sentation du tableau de la fonction, recherchez la plaque dans la colonne des plaques d'immatriculation et obtenez la couleur de la deuxi√®me colonne. Dans cet esprit, on peut identifier l'ensemble _from_ comme l'_entr√©e_ de la fonction, tandis que l'ensemble _to_ est la _sortie_.

Deuxi√®mement, tous les √©l√©ments de l'entr√©e doivent √™tre li√©s √† un √©l√©ment de l'ensemble de sortie. Dans notre exemple, chaque voiture du bloc a une couleur attribu√©e dans le tableau. Cela signifie qu'il ne peut pas y avoir de cellules vides dans la deuxi√®me colonne de notre tableau.

> ‚ùì Pouvez-vous proposer d'autres exemples de fonctions dans le monde r√©el¬†?

En math√©matiques, les fonctions sont omnipr√©sentes. Supposons que $x$ est un nombre r√©el et d√©finissons la fonction

$$
f(x) = x + 1, 
$$

c'est-√†-dire la fonction qui renvoie la valeur $x$ plus un. L'ensemble d'entr√©e (qui est appel√© le _domaine_ de la fonction en math√©matiques) est l'ensemble de toutes les valeurs r√©elles, $\mathbb{R}$, tandis que l'ensemble de sortie (le _codomaine_ en math√©matiques) est √©galement $\mathbb{R}$ , car l'ajout d'un √† n'importe quel nombre r√©el est √©galement un autre nombre r√©el. En utilisant la notation _fl√®che_, la d√©finition compl√®te de la fonction serait

$$
f: \mathbb{R} \rightarrow \mathbb{R} \; ; \;  x \mapsto x + 1,
$$

qui peut √™tre lu comme suit : $f$ est une fonction de $\mathbb{R}$ √† $\mathbb{R}$ telle que $f$ de $x$ est $x + 1$".

> üîî Un l√©ger d√©tour autour du codomaine. Le codomaine est l'ensemble d'entit√©s dans lesquelles la fonction peut √©ventuellement mapper des valeurs d'entr√©e. Par exemple, dans le cas de la couleur des voitures, le codomaine est simplement l'ensemble de toutes les couleurs possibles. Dans de nombreux cas, ces informations sont trop g√©n√©rales et il est pratique de d√©finir la _plage_ de la fonction, qui est l'ensemble des valeurs r√©elles des sorties dans lesquelles la fonction mappe les entr√©es. La gamme dans l'exemple des voitures est l'ensemble {noir, rouge, blanc}.

### Entr√©es et sorties multiples

Prenons l'exemple d'un distributeur automatique. Dans un distributeur automatique, les produits sont dispos√©s dans des √©tag√®res, chaque √©tag√®re √©tant d√©sign√©e par une lettre. Dans chaque √©tag√®re, les produits sont align√©s et identifi√©s par un num√©ro. Ensuite, en A1 vous avez un sachet de chips, en A2 un chocolat, en B1 un soda, etc. La machine dispose √©galement d'un clavier avec des lettres et des chiffres pour que vous puissiez choisir le produit. Pour acheter quelque chose, vous devez donner de l'argent √† la machine (pi√®ces de monnaie, billets, carte de cr√©dit, etc.), s√©lectionnez le produit en cliquant sur la lettre et le chiffre sur le clavier. La machine renvoie le produit et une remise en argent, le cas √©ch√©ant.
Les entr√©es de notre fonction "vendingMachine" sont l'argent, la lettre et le num√©ro que vous avez s√©lectionn√©s, et les sorties sont le produit et
le cashback (le cas √©ch√©ant).

Un exemple math√©matique pourrait √™tre une fonction de traduction, o√π √©tant donn√© un point avec les coordonn√©es \(x\) et $y$ dans le plan, elle renvoie un point avec les coordonn√©es $x+1$ et $y+1$¬†:

$$
g: \mathbb{R} \times \mathbb{R} \rightarrow \mathbb{R} \times \mathbb{R}  \; ; \;  (x,y) \mapsto (x + 1, y+1)
$$

ou plus succinctement

$$
g(x,y) = (x+1,y+1)
$$

### Application partielle
Lorsque nous alimentons une fonction de plusieurs √©l√©ments d'entr√©e, nous pouvons obtenir la ou les sorties appropri√©es. Mais avoir de nombreuses entr√©es ouvre une nouvelle possibilit√© : que se passe-t-il quand on d√©cide de ne pas compl√©ter toutes les entr√©es ? D√©couvrons-le. Supposons que nous ayons entr√© une facture dans le distributeur automatique. Il est clair que nous n'obtiendrons aucun produit, car la machine a encore besoin de deux entr√©es suppl√©mentaires : la lettre de l'√©tag√®re et le num√©ro de produit que nous voulons. _Apr√®s_ nous aurons termin√© ces deux entr√©es, nous obtiendrons notre friandise (et notre cashback, le cas √©ch√©ant). Ainsi, entrer de l'argent uniquement dans le distributeur automatique conduit √† un √©tat o√π deux entr√©es sont n√©cessaires et deux sorties seront retourn√©es. Mais, c'est _une autre fonction_!!!. Appelons-le `vendingMachineAfterInsertBill` qui re√ßoit la lettre de l'√©tag√®re et le num√©ro de produit que nous voulons et renvoie le produit (et le cashback, le cas √©ch√©ant).

Pour en revenir √† l'exemple math√©matique, alimentons la fonction avec juste la valeur $x = 3$,

$$
g(3,y) = (4,y+1)
$$

Encore une fois, le r√©sultat de l'alimentation de la fonction avec une valeur est une autre fonction¬†:

$$
h: \mathbb{R} \rightarrow \mathbb{R} \times \mathbb{R}  \; ; \;  y \mapsto (4, y+1)
$$

ou

$$
h(y) = (4,y+1)
$$

Cette propri√©t√© des fonctions est appel√©e _application partielle_. Chaque fois que vous ne remplissez pas toutes les entr√©es d'une fonction, vous obtenez une autre fonction.

### Composition
 
Enfin, nous regardons ici comment travailler avec plusieurs fonctions √† la fois. Supposons que nous ayons une fonction `getFirstName` qui, √©tant donn√© le nom complet d'une personne, renvoie le pr√©nom (peu importe √† ce stade les sp√©cificit√©s de l'impl√©mentation, pas m√™me la langue). Par exemple, lorsqu'il est appliqu√© √† 'David Gilmour', il renvoie 'David', ou lorsqu'il est appliqu√© √† 'Annie Lennox', il renvoie, bien s√ªr, 'Annie'.
Nous avons √©galement une fonction `getInitial` qui, pour un nom donn√©, renvoie l'initiale. Dans les cas pr√©c√©dents, 'D' pour 'David' et 'A' pour 'Annie'.

Maintenant, nous voulons construire une fonction qui nous donne l'initiale du pr√©nom, √©tant donn√© le nom complet. Pour 'Paul McCartney'. Nous alimentons 'Paul McCartney' en entr√©e de la fonction `getFirstName`, qui nous donne la sortie 'Paul'. Maintenant, 'Paul' est l'entr√©e de la fonction `getInitial` et renvoie 'P' comme sortie finale.
Cette plomberie o√π la sortie d'une fonction est l'entr√©e d'une autre s'appelle _composition_. Notez qu'il est absolument n√©cessaire que la sortie de la premi√®re fonction appel√©e (`getFirstName`) et l'entr√©e de la seconde (`getInitial`) soient le m√™me type d'entit√©, dans notre cas, les deux sont des pr√©noms.
Vous pouvez [voir ces images pour une explication graphique](https://mathinsight.org/function_machine_composition).

Regardons maintenant un exemple math√©matique. Nous avons d√©fini avant la fonction $f(x)$ qui ajoute un √† $x$, par exemple

$$
f(0) = 0 + 1 = 1
$$

Et si nous appliquions √† nouveau la fonction $f$¬†? Cela signifie calculer

$$
f(f(0)) = f(0) + 1 = 0 + 1 + 1 = 2 
$$

En g√©n√©ral,

$$
f(f(x)) = f(x) + 1 = x + 1 + 1 = x + 2 
$$

Si nous regardons attentivement la derni√®re expression, il semble que composer la fonction revient √† passer la fonction comme entr√©e elle-m√™me ($f(f(x))$). Cela signifie que si nous allons avoir un langage de programmation qui impl√©mente la composition de fonctions, d'une certaine mani√®re, les fonctions devraient pouvoir √™tre transmises en entr√©e √† d'autres fonctions.

> ‚ùóÔ∏è Le fait qu'on utilise la m√™me fonction pour composer avec elle-m√™me n'est pas pertinent dans cette discussion, on peut composer autant de fonctions diff√©rentes que l'on veut, √† condition que les entr√©es et les sorties soient compatibles √† chaque √©tape de composition.

> üîî Cependant, composer cette fonction particuli√®re avec elle-m√™me est int√©ressant. Imagerie n'ayant que le z√©ro et cette fonction. Vous pouvez cr√©er tous les nombres naturels {1, 2, ...} simplement en composant cette fonction avec elle-m√™me encore et encore. Par exemple, $4 = f(f(f(f(0))))$, etc. Par cons√©quent, √©tant donn√© le nombre 0, $f(x) = x + 1$ et la composition de la fonction, on peut obtenir tous les nombres naturels. On dirait qu'il se passe quelque chose ici. Plus d'informations √† ce sujet, esp√©rons-le, dans un prochain √©pisode.

## Functions in F\# 

The F\# language implements functions in such a way that they satisfy the properties mentioned above. To define a function, the language also uses the keyword `let`:


```fsharp
let next x =
    x + 1 
```

We defined the function named `next` that receives an argument `x`. Notice that there are no other symbols or parentheses in the function definition. The body of the function should be indented, and there is no `return` keyword at the end. The function simply returns the last expression found in its body. Clean, isn't it? 
Using the function is easy as well:

```fsharp
let one = next 0 
let two = next (next 0)

printfn "one: %A" one 
printfn "two: %A" two 
```

    one: 1
    two: 2


Notice that there is no need to use parentheses around the argument when using a function. However, you need to use them when passing a more complex expression as the argument to the function, such as in the case of `two`. 

There is another way to write the computation of `two`, by using the _pipe operator_ `|>`:

```fsharp
let anotherTwo =
    0 
    |> next
    |> next 
    
printfn "anotherTwo: %A" anotherTwo
```

    anotherTwo: 2


This operator takes care of the plumbing when calling functions one after another. In the example above, the first `|>` receives `0` as the input, passes it to the next function, the second `|>` receives the output of the first `next` function and feeds it as input to the second `next`. 

Another example. Let us assume that we have the functions `getInitial` and `getFirstName` defined as:

```fsharp
let getInitial name = 
    .... //Implementation not important right now
```

and 

```fsharp
let getFirstName fullName = 
    .... //Implementation not important right now
```

and we defined the value

```fsharp
let paul = "Paul McCartney"
```

Then, 

```fsharp
paul
|> getFirstName
|> getInitial 
```
Here the string value `paul` is fed into the `getFirstName` function as the input by the first pipe `|>`, and returns 'Paul' as output. Then, the string 'Paul' is passed as the input of the function `getInitial` that gives us the 'P'. 

Composition is so important in functional languages, that it has its own symbol in F\#, `>>` :

```fsharp
let add2 = next >> next 
let two' = add2 0 
printfn "%A" two'
```

    2


Yes, you can use the `'` symbol in any identifier! (provided it is not the first character). Note also that we defined a _function_ `add2` by using the composition operator (no argument needed). This is equivalent to:

```fsharp
let add2' x = 
    x
    |> next
    |> next 
```

Remember that there is no return at the end of the function, just the last expression of the function is the return value. 

Back to the names example, to clarify the order in which functions are composed. 

```fsharp
let getInitialFromFirstName fullName =
    fullName
        |> getFirstName 
        |> getInitial 
```
and 

```fsharp
let getInitialFromFirstName' =
        getFirstName >> getInitial 
```

are equivalent. 

> ‚ùì Think about routines, procedures or functions that maybe you have written in your language of preference. Do they behave as F\# functions? What are the main differences you see?

> üèãüèΩ We have a function `mult2` that given a number `x` doubles that number. Without coding, can you determine what the next composite functions return when applied to 3? :

```fsharp
let f = mult2 >> next 
let g = next >> mult2 
```

Code the function `mult2` and see the result by yourself.

Some final remarks for now on functions. First, note that the language use the same keyword `let` to bind simple values and functions to a name or identifier. This emphasizes the fact that in F# functions are 'just' values, and can be treated in the same way as, say, a simpler binding of an expression to an identifier. 
Second, the properties of functions that were discussed above match perfectly inmutability. In fact, functions receive immutable inputs and return an immutable value. 

> Checkout [the Jupyter notebook companion of this guide](https://github.com/fcolavecchia/fp-course/blob/main/en/Functions.ipynb).

